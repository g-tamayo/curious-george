# SPF Check Tool
# Version: 1.0.5
# Author: George Tamayo
# Date: February 15, 2016
# Description: This tool checks sender IP to determine if they are
# an authorized sender, and shows which mechanisms matched (if pass).
# Arguments passed are connecting IP being checked and sender domain/address,
# eg, 'spfcheck 127.0.0.1 sender@example.com'.

import DNS, ipaddress  ### Import py3dns for dns queries
import itertools, sys, re


# Class to create SPF records for domains being tested

class SpfRecord:


    def __init__(self, domain):
        self.domain = domain
        self.permerror = False
        self.redirects = []
        try:
            self.txt = DNS.dnslookup(self.domain, 'txt')  ## Perform DNS query on domain
        except DNS.Base.ServerError:
            self.txt = None
        self.dns_lookups = 1
        if self.txt:   # If query returns a result, continue to find SPF info, else no TXT records exist
            self.spf = self.spf_retrieve()
            self.spf_version, self.mechanisms, self.spf_flag = self.mechanisms_retrieve()
        else:
            self.spf = None
            self.spf_flag = None
            self.mechanisms = []
            self.permerror = True


    def spf_retrieve(self):   # Iterates through txt records to find SPF record
        vspf = []
        for record in self.txt:
            if b'v=spf1' in record[0]:
                vspf.append(record[0].decode('utf-8'))
        if len(vspf) > 1:
            self.permerror = True   # Sets permerror variable to True if multiple SPF records exist
            return None
        elif len(vspf) == 1:
            return vspf[0]
        else:
            return None

    def mechanisms_retrieve(self):
        if 'redirect' in self.spf:   # If redirect is in record, set mechanism to redirect to the next domain
            spf, redir = self.spf.split()
            redir_domain = redir.split('=')[1]
            return spf, redir_domain, 'redirect'
        else:
            spfv, *mechs, flag = self.spf.split()
            return spfv, mechs, flag

    def __next__(self):   # Allows iteration through mechanisms in record
        for mech in self.mechanisms:
            if len(self.mechanisms) > 0:
                return self.mechanisms.pop(0)
            else:
                return None


# Main function that checks on mechanism, then acts accordingly by calling other functions to perform further lookups

def ip_mech_check(spf_ip, domain):

    spf_match = False
    matches = []

    while spf_match is False:

        current = next(domains[domain])

        if not current:
            break

        else:  # If mechanism is returned begin checks

            current = current.split(':', 1)

            if 'ip' in current[0]:
                spf_match = ip_check(spf_ip, current[1])

            elif 'a' in current[0]:  # Checks A/AAAA records for both ipv4 and ipv6
                if len(current) == 1 and '/' in current[0]:
                    a_subnet = current[0].split('/')
                    spf_match = a_subnet_check(spf_ip, [domain, a_subnet[1]])
                elif len(current) == 1:
                    spf_match = a_check(spf_ip, domain)
                elif '/' in current[1]:
                    a_subnet = current[1].split('/')
                    spf_match = a_subnet_check(spf_ip, [domain, a_subnet[1]])
                else:
                    spf_match = a_check(spf_ip, current[1])

            elif 'mx' in current[0]:
                if len(current) == 1 and '/' in current[0]:
                    mx_subnet = current[0].split('/')
                    spf_match = mx_subnet_check(spf_ip, domain + '/' + mx_subnet[1])
                elif len(current) == 1:
                    spf_match = mx_check(spf_ip, domain)
                elif '/' in current[1]:
                    spf_match = mx_subnet_check(spf_ip, current[1])
                else:
                    spf_match = mx_check(spf_ip, current[1])

            elif 'ptr' in current[0]:
                if len(current) == 1:
                    spf_match = ptr_check(spf_ip, domain)
                else:
                    spf_match = ptr_check(spf_ip, current[1])

            elif 'exists' in current[0]:
                try:
                    DNS.dnslookup(current[1], 'a')
                    spf_match = True
                except DNS.Base.ServerError:
                    spf_match = False

            elif 'include' in current[0]:
                domains[sys.argv[2]].dns_lookups += 1
                domains[current[1]] = SpfRecord(current[1])
                include_check = ip_mech_check(spf_ip, current[1])

                if domains[current[1]].spf and include_check:
                    matches.append(include_check)
                    spf_match = True
                elif not domains[current[1]].spf:
                    domains[sys.argv[2]].permerror = True
                    return None

    if spf_match is True:
        matches.append(':'.join(current))
        results = matches
        return results
    else:
        return None


'''
The following functions are checks. If a cidr-length is detected (eg, 127.0.0.1/8),
it will check network based on mechanism's instructions.
'''


def ip_check(ip, match):
    return ip in ipaddress.ip_network(match, strict=False)


def a_check(ipa, match):

    domains[sys.argv[2]].dns_lookups += 1
    match_list = DNS.dnslookup(match,'a')
    if str(ipa) in match_list:
        return True
    else:
        return False


# Arguments passed are connecting ip,[domain, cidr-length], and main domain for total DNS query count.

def a_subnet_check(ipa, domain_cidr):

    domains[sys.argv[2]].dns_lookups += 1
    match_list = DNS.dnslookup(domain_cidr[0],'a')
    cidr = domain_cidr[1]
    for a_ip in match_list:
        if ipa in ipaddress.ip_network(a_ip + '/' + cidr, strict=False):
            return True
    return False


def mx_check(ip, match):

    domains[sys.argv[2]].dns_lookups += 1
    mx_records = sorted(DNS.dnslookup(match, 'mx'))
    for priority, mx_rr in mx_records:
        if a_check(ip, mx_rr) is True:
            return True
    return False


def mx_subnet_check(ip, mx_cidr):

    domains[sys.argv[2]].dns_lookups += 1
    mxrr = mx_cidr.split('/')
    mx_records = sorted(DNS.dnslookup(mxrr[0],'mx'))  # Sorts records based on priority
    cidr = mxrr[1]
    mxrr_ip = []
    for priority, mxrr in mx_records:
        mxrr_ip.append(DNS.dnslookup(mxrr,'a'))
    mx_a = list(itertools.chain.from_iterable(mxrr_ip))
    for a_ip in mx_a:
        if ip in ipaddress.ip_network(a_ip + '/' + cidr, strict=False):
            return True
    return False


def ptr_check(ip, domain):

    domains[sys.argv[2]].dns_lookups += 1
    try:
        ip_ptr = DNS.revlookupall(str(ip))
        for ptr_rr in ip_ptr:
            if domain in ptr_rr:
                return True
            elif a_check(ip, ptr_rr):
                return True
        return False
    except DNS.Base.ServerError:   ### Returns False is DNS query does not return any records.
        return False


def redirect(redirect_domain):

    '''
    If spf_flag is set for redirect, create additional SPFRecord object
    with domain listed (eg, redirect:otherdomain.com)
    '''

    namespace = [redirect_domain]

    while True:
        if domains[namespace[-1]].spf_flag == 'redirect':
            domains[sys.argv[2]].redirects.append('redirect=' + domains[namespace[-1]].mechanisms)
            namespace.append(domains[namespace[-1]].mechanisms)
            domains[namespace[-1]] = SpfRecord(namespace[-1])
            domains[sys.argv[2]].dns_lookups += 1
        else:
            break
    return namespace[-1]


def flatten(results):  # Flattens results in case of nested lists.

    if results:
        temp = results
        while len(temp) > 0:
            yield temp.pop()
            try:
               temp = temp[0]
            except IndexError:
              break


def spf_fail(flag):   ### Following functions define the mechanism, and flag for SPF decisions.

    actions = {
        '+': 'Pass',
        '-': 'Fail',
        '~': 'SoftFail',
        '?': 'Neutral'
    }
    return actions[flag[0]]


def flag_result(flag, s_ip, dom):

    flag_mechanisms = {
        '+': 'SPF Policy allows sender with %s ' % flag,
        '-': 'SPF Policy does not authorize %s on behalf of "%s"' % (s_ip, dom),
        '~': 'SPF Policy does not authorize %s on behalf of %s \nAccept and mark the message' % (s_ip, dom),
        '?': 'SPF Policy does not explicitly define if sender is authorized or not'
    }
    return flag_mechanisms[flag[0]]


# Primary Code

domains = {}

sys.argv = ['spf', '72.14.230.254', 'lmiranda.info']

try:
    ip = sys.argv[1]
    ip = ipaddress.ip_address(ip)
except (ValueError, IndexError):
    print('Please enter a valid IP')
    ip = None

try:
    domain = sys.argv[2]
    if re.search('@.+\..+\.?.+', domain):
        strip = re.search('@(.+\..+\.?.+)', domain)
        sys.argv[2] = strip.groups()[0]
        domain = sys.argv[2]
    domains[domain] = SpfRecord(domain)
except (IndexError, NameError):
    print('Please enter a valid domain')
    domain = None
except DNS.Base.TimeoutError:
    print('DNS Temp Error')
    sys.exit(0)

if domain and ip:

    if domains[domain].spf_flag == 'redirect':
        spf_domain = redirect(domain)
    else:
        spf_domain = domain

    spf_result = ip_mech_check(ip, spf_domain)

    total_dns = domains[sys.argv[2]].dns_lookups
    spf_flag = domains[spf_domain].spf_flag
    rfc7208 = None

    output = list(flatten(spf_result))

    if 'ptr:' in ' '.join(output):
        rfc7208 = True

# Following formats results and prints out in readable format for user.

    print('\nSPF Result' + '\n' + '-' * 11)

    if output and total_dns > 10:
        print('Result: Pass')
        print('***** PermError for RFC violation *****')
        print('%s is an authorized sender on behalf of %s' % (ip, domain))
        print('Mechanism: ' + '\n\t  ---> '.join(domains[sys.argv[2]].redirects + output))
    elif output:
        print('Result: Pass')
        print('%s is an authorized sender on behalf of %s' % (ip, domain))
        print('Mechanism: ' + '\n\t  ---> '.join(domains[sys.argv[2]].redirects + output))
    elif not output:
        print('Result: ' + spf_fail(spf_flag))
        print(flag_result(spf_flag, ip, domain))
    else:
        print('See Additional Information')

    # Additional information shows total DNS queries and any other information available.

    print('\nAdditional Information' + '\n' + '-' * 22)

    if total_dns > 10:
        print('PermError due to too many DNS lookups (RFC 4408)')
        if rfc7208:
            print('Warning: PTR should not be used (RFC 7208)')
        print('Total DNS Lookups = %i\n' % total_dns)
    elif not domains[sys.argv[2]].spf and domains[sys.argv[2]].permerror:
        print('No single valid SPF record exists for "%s"\n' % sys.argv[2])
    elif total_dns <=10:
        if rfc7208:
            print('Warning: PTR should not be used (RFC 7208)')
        print('DNS Queries Performed: %i\n' % total_dns)
else:
    print('Example - spfcheck 127.0.0.1 example.com')
    sys.exit(0)
