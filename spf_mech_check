# SPF Check Tool
# Version: 1.0.5
# Author: George Tamayo
# Description: This tool checks sender IP to determine if they are
#   an authorized sender, and shows which mechanisms matched (if pass).

import DNS, ipaddress  ### Import py3dns for dns queries
import itertools, sys, re

# Class to create SPF records for domains being tested


class SpfRecord:


    def __init__(self, domain):
        self.domain = domain
        self.permerror = False
        self.redirects = []
        try:
            self.txt = DNS.dnslookup(self.domain, 'txt')  ## Perform DNS query on domain
        except DNS.Base.ServerError:
            self.txt = None
        self.dns_lookups = 1
        if self.txt:   # If query returns a result, continue to find SPF info, else no TXT records exist
            self.spf = self.spf_retrieve()
            self.spf_version, self.mechanisms, self.spf_flag = self.mechanisms_retrieve()
        else:
            self.spf = None
            self.spf_flag = None
            self.mechanisms = []
            self.permerror = True


    def spf_retrieve(self):   # Iterates through txt records to find SPF record
        vspf = []
        for record in self.txt:
            if b'v=spf1' in record[0]:
                vspf.append(record[0].decode('utf-8'))
        if len(vspf) > 1:
            self.permerror = True   # Sets permerror variable to True if multiple SPF records exist
            return None
        elif len(vspf) == 1:
            return vspf[0]
        else:
            return None

    def mechanisms_retrieve(self):
        if 'redirect' in self.spf:   # If redirect is in record, set mechanism to redirect to the next domain
            spf, redir = self.spf.split()
            redir_domain = redir.split('=')[1]
            return spf, redir_domain, 'redirect'
        else:
            spfv, *mechs, flag = self.spf.split()
            return spfv, mechs, flag

    def __next__(self):   # Allows iteration through mechanisms in record
        for mech in self.mechanisms:
            if len(self.mechanisms) > 0:
                return self.mechanisms.pop(0)
            else:
                return None


# Main function that checks on mechanism, then acts accordingly by calling other functions to perform further lookups

def ip_mech_check(oip, domain):

    namespace = []   ### Keeps track of multiple domains if redirect or include are called on in mechanism
    spf_ip = ipaddress.ip_address(oip)

    namespace.append(domain)

    spf_match = False
    matches = []


    # If spf_flag is set for redirect, create additional SPFRecord object
    # with domain listed (eg, redirect:otherdomain.com)

    while True:

        if domains[namespace[-1]].spf_flag == 'redirect':
            domains[sys.argv[2]].redirects.append('redirect=' + domains[namespace[-1]].mechanisms)
            namespace.append(domains[namespace[-1]].mechanisms)
            domains[namespace[-1]] = SpfRecord(namespace[-1])
            domains[domain].dns_lookups += 1
            domains[domain].spf_flag = domains[namespace[-1]].spf_flag
        else:
            break

    while spf_match is False:

        current = next(domains[namespace[-1]])

        if not current:
            break

        else:  # If mechanism is returned begin checks

            current = current.split(':', 1)

            if 'ip' in current[0]:
                spf_match = ip_check(spf_ip, current[1])

            elif 'a' in current[0]:  # Checks A/AAAA records for both ipv4 and ipv6
                if len(current) == 1 and '/' in current[0]:
                    a_subnet = current[0].split('/')
                    spf_match = a_subnet_check(spf_ip, a_subnet[1], domain)
                elif len(current) == 1:
                    spf_match = a_check(spf_ip, namespace[-1], domain)
                elif '/' in current[1]:
                    a_subnet = current[1].split('/')
                    spf_match = a_subnet_check(spf_ip, a_subnet, domain)
                else:
                    spf_match = a_check(spf_ip, current[1], domain)

            elif 'mx' in current[0]:
                if len(current) == 1 and '/' in current[0]:
                    mx_subnet = current[0].split('/')
                    spf_match = mx_subnet_check(spf_ip, [namespace[-1] + mx_subnet[1]], domain)
                elif len(current) == 1:
                    spf_match = mx_check(spf_ip, namespace[-1], domain)
                elif '/' in current[1]:
                    spf_match = mx_subnet_check(spf_ip, current[1], domain)
                else:
                    spf_match = mx_check(spf_ip, current[1], domain)

            elif 'ptr' in current[0]:
                if len(current) == 1:
                    spf_match = ptr_check(spf_ip, namespace[1], domain)
                else:
                    spf_match = ptr_check(spf_ip, current[1], domain)

            elif 'exists' in current[0]:
                try:
                    exist_ = DNS.dnslookup(current[1], 'a')
                except DNS.Base.ServerError:
                    exist_ = None
                if exist_:
                    spf_match = True

            elif 'include' in current[0]:
                domains[sys.argv[2]].dns_lookups += 1
                domains[current[1]] = SpfRecord(current[1])
                include_check = ip_mech_check(spf_ip, current[1])

                if domains[current[1]].spf and include_check:
                    matches.append(include_check)
                    spf_match = True
                elif not domains[current[1]].spf:
                    domains[sys.argv[2]].permerror = True
                    return None


    if spf_match is True:
        matches.append(':'.join(current))
        results = matches
        return results
    else:
        return None

# The following functions are checks. If a cidr-length is detected (eg, 127.0.0.1/8),
# it will check network based on mechanism's instructions.


def ip_check(ip, match):
    return ip in ipaddress.ip_network(match, strict=False)


def a_check(ipa, match, dns_count):

    domains[sys.argv[2]].dns_lookups += 1
    match_list = DNS.dnslookup(match,'a')
    if str(ipa) in match_list:
        return True
    else:
        return False


# Arguments passed are connecting ip,[domain, cidr-length], and main domain for total DNS query count.

def a_subnet_check(ipa, match, dns_count):

    domains[sys.argv[2]].dns_lookups += 1
    match_list = DNS.dnslookup(match[0],'a')
    cidr = match[1]
    for a_ip in match_list:
        if ipa in ipaddress.ip_network(a_ip + '/' + cidr, strict=False):
            return True
    return False


def mx_check(ip, match, dns_count):


    domains[sys.argv[2]].dns_lookups += 1
    mx_records = sorted(DNS.dnslookup(match, 'mx'))
    for priority, mx_rr in mx_records:
        if a_check(ip, mx_rr, dns_count) is True:
            return True
    return False


def mx_subnet_check(ip, mxrr, dns_count):

    domains[sys.argv[2]].dns_lookups += 1
    mx_records = sorted(DNS.dnslookup(mxrr[0],'mx'))  # Sorts records based on priority
    cidr = mxrr[1]
    mxrr_ip = []
    for priority, mxrr in mx_records:
        mxrr_ip.append(DNS.dnslookup(mxrr,'a'))
    mx_a = list(itertools.chain.from_iterable(mxrr_ip))
    for a_ip in mx_a:
        if ip in ipaddress.ip_network(a_ip + '/' + cidr, strict=False):
            return True
    return False


def ptr_check(ip, domain, dns_count):

    domains[sys.argv[2]].dns_lookups += 1
    try:
        ip_ptr = DNS.revlookupall(str(ip))
        for ptr_rr in ip_ptr:
            if domain in ptr_rr:
                return True
            elif a_check(ip, ptr_rr, dns_count):
                return True
        return False
    except DNS.Base.ServerError:   ### Returns False is DNS query does not return any records.
        return False


def flatten(results):   # Flattens results in case of nested lists.

    if results:
        temp = results
        while len(temp) > 0:
            yield temp.pop()
            try:
               temp = temp[0]
            except IndexError:
              break


def spf_fail(flag):   ### Following functions define the mechanism, and flag for SPF decisions.

    actions = {
        '+': 'Pass',
        '-': 'Fail',
        '~': 'SoftFail',
        '?': 'Neutral'
    }
    return actions[flag[0]]


def flag_result(flag, s_ip, dom):

    flag_mechanisms = {
        '+': 'SPF Policy allows sender with %s ' % flag,
        '-': 'SPF Policy does not authorize %s on behalf of "%s"' % (s_ip, dom),
        '~': 'SPF Policy does not authorize %s on behalf of %s \nAccept and mark the message' % (s_ip, dom),
        '?': 'SPF Policy does not explicitly define if sender is authorized or not'
    }
    return flag_mechanisms[flag[0]]


# Primary Code

domains = {}

try:
    ip = sys.argv[1]
    ip = ipaddress.ip_address(ip)
except (ValueError, IndexError):
    print('Please enter a valid IP')
    ip = None

try:
    domain = sys.argv[2]
    if re.search('@.+\..+\.?.+', domain):
        strip = re.search('@(.+\..+\.?.+)', domain)
        sys.argv[2] = strip.groups()[0]
        domain = sys.argv[2]
    domains[domain] = SpfRecord(domain)
except (IndexError, NameError):
    print('Please enter a valid domain')
    domain = None

if domain and ip:

    spf_result = ip_mech_check(ip, domain)

    total_dns = domains[domain].dns_lookups
    spf_flag = domains[domain].spf_flag
    rfc7208 = None

    output = domains[sys.argv[2]].redirects + list(flatten(spf_result))

    if 'ptr:' in ' '.join(output):
        rfc7208 = True

# Following formats results and prints out in readable format for user.

    print('\nSPF Result' + '\n' + '-' * 11)

    if spf_result and total_dns > 10:
        print('Result: Pass')
        print('***** PermError for RFC violation *****')
        print('%s is an authorized sender on behalf of %s' % (ip, domain))
        print('Mechanism: ' + ' ---> '.join(output))
    elif spf_result:
        print('Result: Pass')
        print('%s is an authorized sender on behalf of %s' % (ip, domain))
        print('Mechanism: ' + '\n\t  ---> '.join(output))
    elif spf_flag:
        print('Result: ' + spf_fail(spf_flag))
        print(flag_result(spf_flag, ip, domain))
    else:
        print('See Additional Information')

    # Additional information shows total DNS queries and any other information available.

    print('\nAdditional Information' + '\n' + '-' * 22)

    if total_dns > 10:
        print('PermError due to too many DNS lookups (RFC 4408)')
        if rfc7208:
            print('Warning: PTR should not be used (RFC 7208)')
        print('Total DNS Lookups = %i\n' % total_dns)
    elif not domains[domain].spf and domains[domain].permerror:
        print('No single valid SPF record exists for "%s"\n' % domain)
    elif total_dns <=10:
        if rfc7208:
            print('Warning: PTR should not be used (RFC 7208)')
        print('DNS Queries Performed: %i\n' % total_dns)
else:
    print('Example - spfcheck 127.0.0.1 example.com')
    sys.exit(0)
